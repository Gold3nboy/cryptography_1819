\mychapter{5}{Lesson 5} %181010

\section{Stretching a \prg}

Consider this algorithm that uses $G$ to construct $G^{l}$, as depicted in figure \ref{fig:gpowerl}:
\begin{enumerate}
    \item Let $s_{0} \pickUAR \{0,1\}^{\lambda}$
    \item $ \forall i \in [l(\lambda)] $ , let $G(s_{i-1}) = (s_{i}, b_{i})$, where $b_i$ is the extra bit generated by $G$
    \item Compose $(b_{1}, b_{2}, ..., b_{{l(\lambda)}}, s_{{l(\lambda)}})$ and output the result; the outputted string will be $\lambda + l(\lambda)$ bits long
\end{enumerate}

\begin{figure}[h]

    \tikzstyle{box}  = [draw, minimum size=2em]
    \tikzstyle{spc}  = [minimum size=2em]
    \tikzstyle{init} = [pin edge={-to,thin,black}]

    \begin{tikzpicture}[node distance = 1.7cm, auto, >=latex']

        \node (a) {};
        \node (b) [box, right of=a, pin={[init]above:$b_{1}$}] {$G$};
        \node (c) [box, right of=b, pin={[init]above:$b_{2}$}] {$G$};
        \node (d) [spc, right of=c] {$...$};
        \node (e) [box, right of=d, pin={[init]above:$b_{i+1}$}] {$G$};
        \node (f) [spc, right of=e] {$...$};
        \node (g) [box, right of=f, pin={[init]above:$b_{l(\lambda)}$}] {$G$};
        \node (h) [right of=g] {};

        \path[->] (a) edge node {$s_{0}$} (b);
        \path[->] (b) edge node {$s_{1}$} (c);
        \path[->] (c) edge node {$s_{2}$} (d);
        \path[->] (d) edge node {$s_{i}$} (e);
        \path[->] (e) edge node {$s_{i+1}$} (f);
        \path[->] (f) edge node {$s_{l(\lambda)-1}$} (g);
        \draw[->] (g) edge node {$s_{l(\lambda)}$} (h);

    \end{tikzpicture}
    \caption{Constructing $G^{l(\lambda)}$ form $G(\lambda)$}
    \label{fig:gpowerl}
\end{figure}

To prove that this construct is a valid \prg, we will make use of a known technique for proving many other results, which relies heavily on reductions, and is called \textbf{the hybrid argument}.
    
\begin{lemma} \label{lem:hybrid}
    (\textbf{\textit{Hybrid Argument}}) Let $X = \{X_n\}, Y = \{Y_n\}, Z = \{Z_n\} : X \compindist Y \wedge Y \compindist Z$. Then $X \compindist Z$. 
\end{lemma}
\begin{proof}
    $\forall \textsc{ ppt } D$, by using the triangle inequality:
    \begin{align*}
        &|\Pr[D(X_n) = 1] - \Pr[D(Z_n) = 1]| \\
        =\:& |(\Pr[D(X_n) = 1] - \Pr[D(Y_n) = 1]) + (\Pr[D(Y_n) = 1] - \Pr[D(Z_n) = 1])| \\
        \leq\:& |\Pr[D(X_n) = 1] - Pr[D(Y_n) = 1]| + |\Pr[D(Y_n) = 1] - \Pr[D(Z_n) = 1]| \\
        \leq\:& negl(n) + negl(n) \\
        =\:& negl(n) \qedhere
    \end{align*}
\end{proof}

In essence, the hybrid argument proves that computational indistinguishability is transitive across a ``hybrid'' game, or by extension more than one. This property will be very useful in all future proofs.

\begin{theorem}
    If there exists a \prg{} $G(\lambda)$ with one bit stretch, then there exists a \prg{} $G^{l(\lambda)}$ with polynomial stretch relative to its input length:
    \begin{equation*}
        G:\{0,1\}^{\lambda} \to \{0,1\}^{\lambda + 1} \implies \forall l(\lambda) \in \poly{\lambda} \:\exists G^l:\{0,1\}^{\lambda} \to \{0,1\}^{\lambda + l(\lambda)} \qedhere
    \end{equation*} 
\end{theorem}

\begin{proof}

    First off, do observe that, since both $G$ and $l$ are polynomial in $\lambda$, then $G^{l(\lambda)}$, which combines $G$ $l$-many times is polynomial in $\lambda$ too. To prove that $G^{l(\lambda)}$ is indeed a \prg, we will apply the hybrid argument. The hybrids are defined as:
    \begin{itemize}
        \item $H_{\lambda}^{0} := G^{l(\lambda)}(U_{\lambda})$, which is the original construct
        \item $H_{\lambda}^{i} :=
            \begin{cases}
                b_1 , ..., b_{i} \pickUAR \{0,1\} \\
                s_{i} \leftarrow \{0,1\}^{\lambda+i} \\
                (b_{i+1}, ..., b_{l(\lambda)}, s_{l(\lambda)}) := G^{l(\lambda)-i}(s_{i})
            \end{cases}$
        \item $H_{\lambda}^{l(\lambda)} := U_{\lambda + l}$
    \end{itemize}

    Focusing on two subsequent generic hybrids, as shown in figures \ref{fig:prgi} and \ref{fig:prgiplusone}, it can be observed that the only difference between the two resides in how $b_{i+1}$ is generated: in $H^{i}$ it comes from an instance of $G$, whereas in $H^{i+1}$ is chosen at random. $H_{\lambda}^{0}$ is the starting point where all bits are pseudorandom, which coincides with the $G^{l(\lambda)}$, and $H_{\lambda}^{l(\lambda)}$ will generate a totally random string.

    \begin{figure}[h]

        \tikzstyle{int}   = [draw, minimum size=2em]
        \tikzstyle{empty} = [minimum size=2em]
        \tikzstyle{init}  = [pin edge={-to,thin,black}]

        \begin{tikzpicture}[node distance = 1.9cm, auto, >=latex']

            \node (a) [empty, pin={[init]above:$b_{1}$}] {};
            \node (c) [empty, pin={[init]above:$...$}] [right of=a,node distance=1cm] {};
            \node (r) [int, pin={[init]above:$b_{i}$}] [right of=c,node distance=1cm] {$U_{\lambda+1}$};
            \node (d) [int, pin={[init]above:$b_{i+1}$}] [right of=r] {$G$};
            \node (e) [int, pin={[init]above:$b_{i+2}$}] [right of=d] {$G$};
            \node (f) [empty] [right of=e] {$...$};
            \node (g) [int, pin={[init]above:$b_{{l(\lambda)}}$}] [right of=f] {$G$};
            \node (h) [right of=g, node distance=2cm]{};

            \path[->] (r) edge node {$s_{i}$} (d);
            \path[->] (d) edge node {$s_{i+1}$} (e);
            \path[->] (e) edge node {$s_{i+2}$} (f);
            \path[->] (f) edge node {$s_{{l(\lambda)}-1}$} (g);
            \path[->] (g) edge node {$s_{{l(\lambda)}}$} (h);

        \end{tikzpicture}

        \caption{$H_{\lambda}^{i}$}
        \label{fig:prgi}

        \begin{tikzpicture}
            \draw[line width=0.2 mm] (0,0) -- (12,0);
        \end{tikzpicture}

        \begin{tikzpicture}[node distance = 1.9cm, auto, >=latex']
            
            \node (a) [empty, pin={[init]above:$b_{1}$}] {};
            \node (c) [empty, pin={[init]above:$...$}] [right of=a,node distance=1cm] {};
            \node (r) [int, pin={[init]above:$b_{i}$}] [right of=c,node distance=1cm] {$U_1$};
            \node (d) [int, pin={[init]above:$b_{i+1}$}] [right of=r] {$U_{\lambda+1}$};
            \node (e) [int, pin={[init]above:$b_{i+2}$}] [right of=d] {$G$};
            \node (f) [empty] [right of=e] {$...$};
            \node (g) [int, pin={[init]above:$b_{l(\lambda)}$}] [right of=f] {$G$};
            \node (h) [right of=g, node distance=2cm]{};

            \path[->] (d) edge node {$s_{i+1}$} (e);
            \path[->] (e) edge node {$s_{i+2}$} (f);
            \path[->] (f) edge node {$s_{{l(\lambda)}-1}$} (g);
            \path[->] (g) edge node {$s_{{l(\lambda)}}$} (h);

        \end{tikzpicture}
        \caption{$H_{\lambda}^{i+1}$}
        \label{fig:prgiplusone}
    \end{figure}

    So let's fix a step $i$ in the gradual substitution, and consider the following function $f_i$:

    \begin{equation*}
        f_i(s_{i+1}, b_{i+1}) = (b_1, \dots, b_i, b_{i+1}, b_{i+2}, \dots, b_{l(\lambda)}, s_{l(\lambda)})
    \end{equation*}

    where the first i bits are chosen uniformly at random, and the remaining ones are obtained by subsequent applications of G ($\forall j \in \{i+2, \dots, l(\lambda)\} \implies G(s_{j-1})=(s_{j}, b_{j})$). It can be observed that:

    \begin{itemize}
        \item $f_{i}(G(U_{\lambda}))$ has the same distribution of $H_\lambda^{i}$
        \item $f_{i}(U_{\lambda + 1})$ has the same distribution of $H_\lambda^{i+l}$
    \end{itemize}

    Since by \prg{} definition $G(U_{\lambda}) \compindist U_{\lambda + 1}$, by lemma \ref{lem:tria}, we can deduce that $f_{i}(G(U_{\lambda })) \compindist f_{i}(U_{\lambda + 1})$, which in turn, by how $f$ is defined, implies $H^{i} \compindist H^{i + 1}$. This holds for an arbitrary choice of $i$, so by extension:

    \begin{equation*}
        G^{l(\lambda)}(U_\lambda) = H_{\lambda}^{0} \compindist H_{\lambda}^{1} \compindist \dots \compindist H_{\lambda}^{{l(\lambda)}} = U_{\lambda + l(\lambda)}
    \end{equation*}

    which proves that $G^l$ is indeed a \prg.
\end{proof}

\begin{proof}
    \textit{(Contradiction)}: This is an alternate proof that, instead of looking for a function $f$ to model hybrid transitioning, aims for a contradiction.
    
    Suppose $G^{l}$ is not a \prg; then there must be a point in the hybrid chain $H_{\lambda}^{0} \compindist \dots \compindist H_{\lambda}^{l}$ where $H_{\lambda}^{i} \not\compindist H_{\lambda}^{i+1}$. Thus there exists a distinguisher $D'$ able to tell apart $H_{\lambda}^{i}$ from $H_{\lambda}^{i+1}$, as shown in figure \ref{cryptogame:prghybdist}:

    \begin{equation*}
        \exists i \in [0,l], \exists\; \textsc{ppt}\; D' : \lvert\Pr[D'(H_{\lambda}^{i}) = 1] - \Pr[D'(H_{\lambda}^{i+l}) = 1]\rvert \geq \frac{1}{\poly{(\lambda)}}
    \end{equation*}

    \begin{cryptogame}{prghybdist}{Distinguisher for $H_{\lambda}^{i}$ and $H_{\lambda}^{i+1}$}{i-dist}

        \receive{\shortstack[l]{
            $Z \pickUAR \{H_{\lambda}^{i}, H_{\lambda}^{i+1}\} \simeq \{0, 1\}$ \\
            $z \pickUAR Z$}}
        {$z = (b_{1}, \dots ,b_{l(\lambda)}, s_{l(\lambda)})$}{}

        \cseqdelay
        
        \send{}{$a$}{\textsc{Output 1 iff} $a \simeq Z$}

    \end{cryptogame}

    If such a distinguisher exists, it can be also used to distinguish an output of $G$ from a $\lambda+1$ uniform string by ``crafting'' a suitable bit sequence, which will distribute exactly as the hybrids in question, as shown in the reduction in figure \ref{cryptoredux:prghyb}. This contradicts the hypothesis of $f$ being a \prg, which by definition is to be indistinguishable from a truly random distribution. Therefore, $G^l$ is indeed a \prg.

    \begin{cryptoredux}{prghyb}{Reducing to a distinguisher for $G$, where $\beta = (b_1, \dots, b_{i-1})$ and $\sigma = (b_{i+1}, \dots, b_{l(\lambda)}, s_{l(\lambda))}$}{prg}{i-dist}

        \receive{\shortstack[l]{
            $s \pickUAR U_\lambda$ \\
            $z_0 = G(s)$ \\
            $z_1 \pickUAR U_{\lambda+1}$ \\
            $a \pickUAR \{0, 1\}$}}
        {$z_a = (b, s)$}{}

        \cseqdelay

        \invoke{\shortstack[l]{
            $\beta \pickUAR U_{i}$ \\
            $\sigma = G^{l(\lambda)-i+1}(s)$
        }}
        {$(\beta, b, \sigma)$}{}
        
        \cseqdelay

        \return{}{$a'$}{}
        \send{}{$a'$}{\textsc{Output 1 iff} $a' = a$}
    
    \end{cryptoredux}

\end{proof}

\pagebreak

\section{Hardcore predicate}

We've seen how to reuse a \prg{} in order to obtain an arbitrary length of pseudorandom bits starting from a \prg{} with one bit stretch. How to construct a 1-bit \prg?

Consider a typical one-way function $f$, s.t. $f(x) = y$.
\begin{question}
    Which bits of the input x are hard to compute given $y = f(x)$?

    Is it always true that, given $f$, the first bit of $f(x)$ is hard to compute $\forall x$?
\end{question}

\begin{example}
    Given an OWF $f$, then $f'(x) = x_0 || f(x)$ is a OWF.
\end{example}


\begin{defn}
    A polynomial time function $\mathfrak{hc}:\{0,1\}^{n} \to \{0,1\} $ is \textbf{hard core} for a given function $f:\{0,1\}^{n} \to \{0,1\}^{n}$ if, $\forall\; \textsc{ppt}\; A$:
    \begin{equation*}
        \Pr(A(f(x)) = \mathfrak{hc}(x) | x \pickUAR \{0,1\}^{n}) \in \negl{\lambda)}   
    \end{equation*}
\end{defn}

\begin{cryptogame}{hcpreddef1}{The hardcore game, $f$ and $\mathfrak{hc}$ are known}{hc(1)}
    \receive{$x \pickUAR \{0, 1\}^n$}{$f(x)$}{}

    \send{}{$b$}{\textsc{Output 1 iff} $b = \mathfrak{hc}(x)$}
\end{cryptogame}


There is also an alternative definition:
\begin{defn}
    A polynomial time function $\mathfrak{hc} : \{0,1\}^n \to \{0,1\}$ is hard-core for  a function $f$ iff:
    \begin{equation*}
        (f(x), h(x)) \compindist (f(x), b)
    \end{equation*}
    where $x \pickUAR \{0, 1\}^n$ and $b \pickUAR \{0, 1\}$.
\end{defn}


\begin{cryptogame}{hcpreddef2}{Another hardcore game, $f$ and $\mathfrak{hc}$ are known}{hc(2)}
    \cseqdelay
    \receive{\shortstack[l]{
        $x \pickUAR \{0, 1\}^n$ \\
        $z_0 = \mathfrak{hc}(x)$ \\
        $z_1 \pickUAR \{0, 1\}$ \\
        $b \pickUAR \{0, 1\}$
    }}{$(f(x), z_b)$}{}

    \cseqdelay
    \cseqdelay

    \send{}{$b'$}{\textsc{Output 1 iff} $b' = b$}
\end{cryptogame}

% Theorem-as-exercise: The two definitions are equivalent

Having made this definition, some observations are in order:

\begin{clm}
    There is no \textit{universal} hardcore predicate $\mathfrak{HC}$.
\end{clm}

\begin{proof}
    Suppose there exists such a predicate $\mathfrak{HC}$. Let $f'(x) = \mathfrak{HC}(x) || f(x)$ for a given function $f$. Then $\mathfrak{HC}$ cannot be a hardcore predicate of $f'$, because any image obtained by $f$ reveals the predicate image itself. This contradicts the universailty assumption.
\end{proof}

Nevertheless, it has been proven always possible to construct a hardcore predicate for a \owf{}, given another \owf:

\begin{theorem}[Goldreich-Levin, '99]
    Let $f$ be a \owf{} and consider $g(x,r)=(f(x), r)$ for $r \in \{0,1\}^{n}$.
    Then $g$ is a \owf{} and:
    \begin{equation*}
        h(x,r) = <x, r> = \sum_{i=1}^{n}x_ir_i\;\; mod\, 2 = \bigxor_{i=1}^{n}x_ir_i
    \end{equation*}
    is hard core for $g$.
\end{theorem}

\begin{proof}
    \todo{TO BE COMPLETED (...did we actually do this? è una bella menata dimostrare questo)}
\end{proof}

\begin{exercise}
    Prove that $g$ is a \owf{} if $f$ is a \owf{} (Hint: do a reduction).
\end{exercise}

\section{One Way Permutation}
$f:{\{0,1\}^{n}} \to {\{0,1\}^{n}} $ is an OWF and 
\[
    \forall x, |x|=|f(x)| \wedge  x \not= x' \Rightarrow f(x) \not= f(x')
\]

\begin{cor}
    If $f:\{0,1\}^{n} \to \{0,1\}^{n} $ is a OWP, then for $g(), h()$ as in the
    GL theorem,
    \[
        G(s)=(g(s), h(s))
    \]
    is a PRG.
\end{cor}

\begin{proof}
    By GL , if $f$ is an OWP, so is $g$. This means that if we want to invert
    $g$, since $g$ depends on $f$ we have to invert a OWP.\\
    Moreover $h$ is hardcore for $g$.
    Hence
    \[
        G(U_{2n}) \equiv (g(U_{2n}), h(U_{2n})) \equiv \underbrace{(f(U_{n}), U_{n},
        h(U_{2n})) \approx_{c}(f(U_{n}), U_{n}, U_{1})}_{\text{definition 1 of hard core pred.}}  \equiv U_{2n+1}
    \]

\end{proof}

We are stretching just 1 bit, but we know we can stretch more than one.
\pagebreak
