\mychapter{7}{Lesson 7}
\textbf{WARNING : I was absent} 
\begin{theorem}
    If $G$ is a PRG, then $F_{GGM}$ is a PRF.
\end{theorem}
(this definition should mean implicitly that the $k$ key has been chosen by the
challenger before the proof starts)

\begin{proof} 
    \todo{TO BE REVIEWED.}
    Now use the induction on the height $n$ of the GGM tree for $\nu(\lambda)
    \in \poly{\lambda} $.
    
    \textbf{Base Case $\Rightarrow n=1$} follows by security of PRG $G$ function, because
    \begin{equation*}
        (F_{k}(0), F_{k}(1))=(G_{0}(k), G_{1}(k)) \approx_{c} U_{2\lambda}
    \end{equation*}

    This means that, chosen $k$, the two values returned by $F$ are
    indistinguishable from 2 values taken at random and inserted in the
    truth table of a possible random function. Since these values are
    indistinguishables, the source functions are indistinguishables and $F_{k}$
    is pseudorandom.
    
    Now, for the \textbf{Inductive step}:

    \begin{lemma}
       Let $F':\{0,1\}^{n-1} \to \{0,1\}^{\lambda} $ be a PRF.
       Now define $F_{k}(x,y)=G_{x}(F_{k}'(y))$ where $F_{k}:\{0,1\}^{n} \to
       \{0,1\}^{\lambda} $.

       If $\{F_{k}'\}$ is a PRF so is $ \{F_{k}\}$.
    \end{lemma}
    
    Consider the following images:

    
    \newpage
    \begin{figure}[h!]
       \centering
       \sdinit{}
       \begin{tikzpicture}[scale=.6]
          % Define symbols and names for the parties
          \sdbegin{}
          \newinst{A}{$ \A $}
          \newinst[5]{B}{$C$} % Increase "5" to widenC
          
          \mess{A}{$x,y$}{B}
          \node[anchor=west] at (mess to) {  };
    
          \postlevel
          \mess{B}{z}{A}
          \node[anchor=west] at (mess from) {\shortstack[l]{
          		$ k \leftarrow\$ {0,1}^{\lambda}
          		   $ 
                \\
        $  z=F_{k}(x,y)=G_{x}(F_{k}'(y))  $ }};
          
          % Message from Bob to Alice, with computations by both sides
          
          \sdend{}
       \end{tikzpicture}
       \caption{$ \H\Y\B_{\F, \A}^{0}(\lambda) $}
       \label{fig:hib0}
    \end{figure}
    
    
    \begin{figure}[h!]
        \centering
       \sdinit{}
       \begin{tikzpicture}[scale=.6]
          % Define symbols and names for the parties
          \sdbegin{}
          \newinst{A}{$ \A $}
          \newinst[5]{B}{$C$} % Increase "5" to widen
          
          \mess{A}{$x,y$}{B}
          \node[anchor=west] at (mess to) {  };
    
          \postlevel
          \mess{B}{z}{A}
          \node[anchor=west] at (mess from) {\shortstack[l]{
                      $ R' \leftarrow\$ \R'(\lambda, n-1, \lambda) $ 
                \\
        $  z=H(x, y)=G_{x}(R'(y))  $ }};
          
          % Message from Bob to Alice, with computations by both sides
          
          \sdend{}
       \end{tikzpicture}
       \caption{$ \H\Y\B_{\R', G, \A}^{1}(\lambda) $}
       \label{fig:hib1}
    \end{figure}
    
    
    \begin{figure}[h!]
       \centering
       \sdinit{}
       \begin{tikzpicture}[scale=.5]
          % Define symbols and names for the parties
          \sdbegin{}
          \newinst{A}{$ \A $}
          \newinst[5]{B}{$C$} % Increase "5" to widen
          
          \mess{A}{$x,y$}{B}
          \node[anchor=west] at (mess to) {  };
    
          \postlevel
          \mess{B}{z}{A}
          \node[anchor=west] at (mess from) {\shortstack[l]{
                      $ R \leftarrow\$ \R(\lambda, n, \lambda) $ 
                \\
        $  z=R(x, y)  $ }};
          
          % Message from Bob to Alice, with computations by both sides
          
          \sdend{}
       \end{tikzpicture}
       \caption{$ \H\Y\B_{\R, \A}^{2}(\lambda) $}
       \label{fig:hib2}
    \end{figure}
    
    \begin{lemma}
$\H\Y\B^{0} \approx_{c} \H\Y\B^{1} \approx_{c} \H\Y\B^{2}$.
    \end{lemma}

    \begin{clm}
 $\H\Y\B^{0} \approx_{c} \H\Y\B^{1}$       
    \end{clm}

   Assume $ \exists .PPT. D_{01}$ that can distinguish $F_{k}$ and $H$ ; then
   there may exist a distinguisher $D$ as in the image which breaks the
   assumption made by inductive step.
\begin{figure}[h!]
   \centering
   \sdinit{}
   \begin{tikzpicture}
      % Define symbols and names for the parties
      \sdbegin{}
      \newinst{A}{$ D_{01}  $}
      \newinst[3]{B}{$ D $} % Increase "5" to widen
      \newinst[3]{C}{$\C  $}

      \mess{A}{$x, y$}{B}
      \node[anchor=west] at (mess to) {  };
      \mess{B}{$y$}{C}
      \node[anchor=west] at (mess to) {  };

      \postlevel
      \mess{C}{$z'$}{B}
      \node[anchor=west] at (mess from) {\shortstack[l]{
      		$  k \leftarrow\$ U_{\lambda}  $ 
            \\
            $z'=F_{k}(y)$ or $z'=R'(y)$
            \\
    $ R' \leftarrow\$ \R'(\lambda, n-1, \lambda)$;}};     
      \mess{B}{$G_{x}(z')$}{A}
      \node[anchor=west] at (mess to) {  };
      \sdend{}
   \end{tikzpicture}
\end{figure}

\begin{clm}
 $\H\Y\B^{1} \approx_{c} \H\Y\B^{2}$       
\end{clm}

For this proof we use the following simple lemma.
\begin{lem}
    If $ G:\{0,1\}^{\lambda} \to \{0,1\}^{2\lambda} $ is a PRG, then for any
    $t(\lambda) \in \poly{\lambda} $
    \[
        (G(k_{1}), ..., G(k_{t})) \approx_{c} (U_{2\lambda}, ..., U_{2\lambda})
    \]
    for $k_{1}, ..., k_{t} \leftarrow\$ U_{\lambda}$
\end{lem}

Assume that it exists a distinguisher $D_{1, 2}$ which is capable of distinguish $H(x, y)$ and $R(x, y)$.

...TO REVIEW, NOT UNDERSTOOD AT ALL ...
\end{proof}

\section{\textsc{Cpa}-security}

Now it's time to define a stronger notion of security, which is widely used in cryptology for first assessments on cryptographic schemes. Let $\Pi := (Enc, Dec)$ be a \ske{} scheme, and consider the game depicted in figure \ref{cryptogame:cpadef}. Observe that this time, the adversary can ``query'' the challenger for the ciphertexts of any messages of his choice, with the only reasonable restriction that the query amount must be polynomially bound by $\lambda$. This kind of game/attack is called the \emph{Chosen Plaintext Attack}, because of the adversary's capability of obtaining ciphertexts from messages. The usual victory conditions found in n-time security games, which are based on ciphertext distinguishability, apply.

\begin{cryptogame}
    {cpadef}
    {The \cpa-security game: $\cryptog{cpa}(\lambda, b)$}
    {cpa}

    \cseqchallenger{$k \pickUAR \{0, 1\}^\lambda$}

    \cseqbeginloop
    \send{}{$m$}{}
    \receive{$c \pickUAR Enc(k, m)$}{$c$}{}
    \cseqendloop

    \cseqdelay

    \send{}{$m_0^*, m_1^*$}{}
    \receive{\shortstack[l]{
        $b \pickUAR \{0, 1\}$ \\
        $c^* \pickUAR Enc(k, m_b^*)$
    }}{$c^*$}{}

    \cseqdelay

    \cseqbeginloop
    \send{}{$m$}{}
    \receive{$c \pickUAR Enc(k, m)$}{$c$}{}
    \cseqendloop

    \cseqdelay

    \send{}{$b'$}{\textsc{Output 1 iff} $b' = b$}

\end{cryptogame}

\begin{definition}
    A scheme is \cpa-secure if $\cryptog{cpa}(\lambda, 0) \compindist \cryptog{cpa}(\lambda, 1)$
\end{definition}


Having given this definition of security, recall the $\Pi_{\xor}$ scheme defined in the previous lesson. It is easy to see that $\Pi_{\xor}$ is not \cpa-secure for the same reasons that it is not computationally 2-time secure; however this example sheds some new light about a deeper problem:

%AP181230: Refer to page 72 of Katz-Lindell for a good explanation
\begin{observation}
    No deterministic scheme can achieve \cpa-security.
\end{observation}

This is true, because nothing prevents the adversary from asking the challenger to encrypt either $m_0$ or $m_1$, or even both, before starting the actual challenge; just as in the 2-time case for $\Pi_{\xor}$, he will know the messages' ciphertexts in advance, so he will be able to tell which message the challenger has encrypted every time. The solution for obtaining a \cpa-secure encryption scheme consists of returning different ciphertexts for the same message, even better if they look random. This can be achieved by using \prf{}s.

Consider the following \ske{} scheme $\Pi_{\F}$, with $\F=\{ F_{k}:\{0,1\}^{n} \to \{0,1\}^{l} \}$ being a \prf:

\begin{itemize}
    \item $Enc(k, m) = (c_1, c_2) = (r, F_k(r) \xor m)$, where $k \pickUAR \{0,1\}^\lambda$ and $r \pickUAR \{0,1\}^n$
    
    \item $Dec(k, (c_{1}, c_{2}))=F_{k}(c_{1}) \xor c_{2}$
\end{itemize}

Observe that the random value $r$ is part of the ciphertext, making it long $n+l$ bits; also more importantly, the adversary can and will always see $r$. The key $k$ though, which gives a \textit{flavour} to the \prf, is still secret.

\begin{theorem}
    If $\F$ is a \prf, then $\Pi_{\F}$ is \cpa-secure.
\end{theorem}

\begin{proof}
    We have to prove that $\cryptog{cpa}[\Pi_{\F}](\lambda, 0) \compindist \cryptog{cpa}[\Pi_{\F}](\lambda, 1)$; to this end, the hybrid argument will be used. Let the first hybrid $\hybridg{0}$ be the original game, the second hybrid $\hybridg{1}$ will have a different encryption routine:

    \begin{itemize}
        \item $r \pickUAR \{0, 1\}^n$
        \item $R \pickUAR \R(\lambda, n, l)$
        \item $c = (r, R(r) \xor m)$, where $m$ is the plaintext to be encrypted
    \end{itemize}

    and then the last hybrid $\hybridg{2}$ will simply output $(r_1, r_2) pickUAR U_{n+l}$.

    \begin{lemma}
        $\forall b \in \{0, 1\} \implies \hybridg{0}(\lambda, b) \compindist \hybridg{1}(\lambda, b)$.
    \end{lemma}

    \begin{proof}
        As usual, the proof is by reduction: suppose there exists a distinguisher $\distinguisher$ capable of telling the two hybrids apart; then $\distinguisher$ can be used to break $\F$'s property of being a \prf. The way to use $\distinguisher$ is to make it play a \cpa-like game, as shown in figure \ref{cryptoredux:prfcpa}\footnotemark, where the adversary attempting to break $\F$ decides which message to encrypt between $m_0$ and $m_1$ beforehand, and checks whether $\distinguisher$ guesses which message has been encrypted. Either way, the adversary can get a sensible probability gain in guessing if the received values from the challenger were random, or generated by $\F$. Thus, assuming such $\distinguisher$ exists, $\adversary$ can efficiently break $\F$, which is absurd.

        \footnotetext{An observant student may notice a striking similarity with a previously exposed reduction in figure \ref{cryptoredux:xorotprg}}

        % AP190101: Potrei includere una definizione alternativa di prf più su, in modo tale che questa riduzionie sia un po' più chiara

        \begin{cryptoredux}
            {prfcpa}
            {Breaking a \prf, for fixed message choice of $m_0$}
            {prf}
            {}

            \cseqchallenger{\shortstack[l]{
                $k \pickUAR \{0, 1\}^\lambda$ \\
                $b \pickUAR \{0, 1\}$
            }}
        
            \cseqbeginloop
            \return{}{$m$}{}
            \send{$r \pickUAR \{0, 1\}^n$}{$r$}{}
            \receive{\shortstack[l]{
                $z_0 \pickUAR F_k(r)$ \\
                $z_1 \pickUAR R(r)$
            }}{$z_b$}{}
            \invoke{$c = (r, z_b \xor m)$}{$c$}{}
            \cseqendloop

            \cseqdelay
        
            \return{}{$m_0^*, m_1^*$}{}
            \send{$r^* \pickUAR \{0, 1\}^n$}{$r^*$}{}
            \receive{\shortstack[l]{
                $z_0^* \pickUAR F_k(r)$ \\
                $z_1^* \pickUAR R(r)$
            }}{$z_b^*$}{}
            \invoke{$c^* = (r^*, z_b^* \xor m_0^*)$}{$c^*$}{}

            \cseqdelay
        
            \cseqbeginloop
            \return{}{$m$}{}
            \send{$r \pickUAR \{0, 1\}^n$}{$r$}{}
            \receive{\shortstack[l]{
                $z_0 \pickUAR F_k(r)$ \\
                $z_1 \pickUAR R(r)$
            }}{$z_b$}{}
            \invoke{$c = (r, z_b \xor m)$}{$c$}{}
            \cseqendloop
            
            \cseqdelay
        
            \return{}{$b'$}{}

            \cseqdelay

            \send{$b'' = \begin{cases}
                0 &\textsc{iff } b'=0 \\
                1 &\textsc{else}
            \end{cases}$
            }{$b''$}{\textsc{Output 1 iff} $b'' = b$}
        
        \end{cryptoredux}

    \end{proof}

    \begin{lemma}
        $\forall b \in \{0, 1\} \implies \hybridg{1}(\lambda, b) \compindist \hybridg{2}(\lambda, b)$.
    \end{lemma}

    \begin{proof}
        Firstly, it can be safely assumed that any ciphertext $(r_i, R(r_i) \xor m_b)$ distributes equivalently with its own sub-value $R(r_i)$, because of $R$'s true randomness, and independency from $m_b$.

        Having said that, the two hybrids apparently distribute uniformly, making them perfectly equivalent; however there is a caveat: if both games are run and one value $\bar{r}$ is queried twice in both runs, then om the second query, the adversary will receive the same image in $\hybridg{1}$, but almost certainly a different one in $\hybridg{2}$. This is because the first hybrid uses a function, which is deterministic by its nature, whereas the image in the second hybrid is picked completely randomly from the codomain. Nevertheless, this sneaky issue about "collisions" can be proven to happen with negligible probability.

        Call \textsc{Repeat} this collision event on $\bar{r}$ between 2 consecutive games. Then:
        
        % AP190102: Could use some clarifications? Especially about what the indices represent
        \begin{align*}
        \Pr[\textsc{Repeat}] &= \Pr[\exists i, j \in q \text{ such that } r_i = r_j] \\
            &\leq \sum_{i \neq j} \Pr[r_i=r_j] \\
            &= Col(U_n) \\
            &= \sum_{i \neq j} \sum_{e \in \{0, 1\}^n} \Pr[r_1 = r_2 = e] \\
            &= \sum_{i \neq j} \sum_{e \in \{0, 1\}^n} \Pr[r = e]^{2} \\
            &= {q \choose 2} 2^{n} \frac{1}{2^{2n}} \\
            &= {q \choose 2} 2^{-n} \\
            &\leq q^{2}2^{-n} \in \negl{\lambda} 
        \end{align*} 


        which proves that the \textsc{Repeat} influences negligibly on the two hybrids' equivalence. Thus $\hybridg{1}(\lambda, b) \compindist \hybridg{2}(\lambda, b)$\footnotemark.
        
        \footnotetext{Do note that the hybrids lose their originally supposed perfect equivalence ($\hybridg{1}(\lambda, b) \equiv \hybridg{2}(\lambda, b)$) because of the \textsc{Repeat} event. The lemma, though, is still proven.}
    \end{proof}

    With the above lemmas, and observing that $\hybridg{2}(\lambda, 0) \equiv \hybridg{2}(\lambda, 1)$, we can reach the conclusion that $\hybridg{0}(\lambda, 0) \compindist \hybridg{0}(\lambda, 1)$, which is what we wanted to demonstrate.

\end{proof}
